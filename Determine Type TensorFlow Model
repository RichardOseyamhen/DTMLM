import pandas as pd
import tensorflow as tf
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder, OneHotEncoder
from tensorflow.keras.callbacks import EarlyStopping

# Load the dataset
url = "https://raw.githubusercontent.com/RichardOseyamhen/BeybladeStatsDatasets/main/BeybladeStatsDataset%232.csv"
df = pd.read_csv(url)

# Extract features and labels
# Assuming the dataset columns are ordered as you listed
X = df[['Attack_EnergyRing', 'Defense_EnergyRing', 'Stamina_EnergyRing',
        'Attack_FusionWheel', 'Defense_FusionWheel', 'Stamina_FusionWheel',
        'Attack_PerformanceTip', 'Defense_PerformanceTip', 'Stamina_PerformanceTip',
        'EnergyRing', 'FusionWheel', 'SpinTrack', 'PerformanceTip']]

# Encode categorical labels
label_encoder = LabelEncoder()
y_encoded = label_encoder.fit_transform(df['Type'])

# Include all numerical columns before one-hot encoding
numerical_columns = ['Attack_EnergyRing', 'Defense_EnergyRing', 'Stamina_EnergyRing',
                      'Attack_FusionWheel', 'Defense_FusionWheel', 'Stamina_FusionWheel',
                      'Attack_PerformanceTip', 'Defense_PerformanceTip', 'Stamina_PerformanceTip']

# Use OneHotEncoder for categorical features
categorical_features = ['EnergyRing', 'FusionWheel', 'SpinTrack', 'PerformanceTip']
onehot_encoder = OneHotEncoder(handle_unknown='ignore')
X_categorical_original = pd.DataFrame(onehot_encoder.fit_transform(X[categorical_features]).toarray())

# Ensure all column names are strings for the original dataset
X_categorical_original.columns = X_categorical_original.columns.astype(str)

# Concatenate the numerical and one-hot encoded categorical features for the original dataset
X_original = pd.concat([X[numerical_columns], X_categorical_original], axis=1)

# Ensure all column names are strings for the original dataset
X_original.columns = X_original.columns.astype(str)

# Now, include all numerical columns when fitting the scaler
scaler = StandardScaler()
scaler.fit(X_original[numerical_columns])

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X_original, y_encoded, test_size=0.2, random_state=42)

# Ensure that the feature names in the test set match the feature names in the training set
X_test_original = X_test.copy()  # No need to modify the test set

# Standardize the feature values for the training and testing sets
X_train_scaled = pd.DataFrame(scaler.transform(X_train[numerical_columns]), columns=numerical_columns)
X_test_scaled = pd.DataFrame(scaler.transform(X_test_original[numerical_columns]), columns=numerical_columns)

# Build the model
num_classes = len(label_encoder.classes_)
model = tf.keras.models.Sequential([
    tf.keras.layers.Dense(64, activation='relu', input_shape=(X_train_scaled.shape[1],)),
    tf.keras.layers.Dense(32, activation='relu'),
    tf.keras.layers.Dense(num_classes, activation='softmax')
])

# Compile the model with sparse categorical cross-entropy
model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

# Train the model with early stopping
early_stopping = EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True)
model.fit(X_train_scaled, y_train, epochs=250, validation_data=(X_test_scaled, y_test), callbacks=[early_stopping])

# Evaluate the model
test_loss, test_accuracy = model.evaluate(X_test_scaled, y_test)
print(f'Test Accuracy: {test_accuracy}')

# Make predictions for a new Beyblade preset
new_beyblade_data = pd.DataFrame({
    'Attack_EnergyRing': 1,  # Replace with the actual values
    'Defense_EnergyRing': 4,
    'Stamina_EnergyRing': 2,
    'Attack_FusionWheel': 1,
    'Defense_FusionWheel': 4,
    'Stamina_FusionWheel': 2,
    'Attack_PerformanceTip': 1,
    'Defense_PerformanceTip': 5,
    'Stamina_PerformanceTip': 1,
    'EnergyRing': 'Leone',  # Add the EnergyRing value
    'FusionWheel': 'Rock',  # Add the FusionWheel value
    'SpinTrack': '145',  # Add the SpinTrack value
    'PerformanceTip': 'WB'  # Add the PerformanceTip value
}, index=[0])

# Calculate totals for the new Beyblade data
new_beyblade_data['Attack_Total'] = new_beyblade_data['Attack_EnergyRing'] + new_beyblade_data['Attack_FusionWheel'] + new_beyblade_data['Attack_PerformanceTip']
new_beyblade_data['Defense_Total'] = new_beyblade_data['Defense_EnergyRing'] + new_beyblade_data['Defense_FusionWheel'] + new_beyblade_data['Defense_PerformanceTip']
new_beyblade_data['Stamina_Total'] = new_beyblade_data['Stamina_EnergyRing'] + new_beyblade_data['Stamina_FusionWheel'] + new_beyblade_data['Stamina_PerformanceTip']

# One-hot encode the categorical features for the new Beyblade data
new_beyblade_categorical = pd.DataFrame(onehot_encoder.transform(new_beyblade_data[['EnergyRing', 'FusionWheel', 'SpinTrack', 'PerformanceTip']]).toarray())

# Ensure all column names are strings for the new Beyblade data
new_beyblade_categorical.columns = new_beyblade_categorical.columns.astype(str)

# Concatenate the numerical and one-hot encoded categorical features for the new Beyblade data
new_beyblade_data_encoded = pd.concat([new_beyblade_data[numerical_columns], new_beyblade_categorical], axis=1)

# Transform the new Beyblade data using the fitted scaler
new_beyblade_data_scaled = pd.DataFrame(scaler.transform(new_beyblade_data_encoded[numerical_columns]), columns=numerical_columns)

# Make predictions for the new Beyblade preset
predictions = model.predict(new_beyblade_data_scaled)

# Decode the predicted label
predicted_label = label_encoder.inverse_transform([tf.argmax(predictions[0])])[0]

# Printing the totals
print(new_beyblade_data['Attack_Total'])
print(new_beyblade_data['Defense_Total'])
print(new_beyblade_data['Stamina_Total'])

# Print prediction
print(f'Predicted Beyblade Type: {predicted_label}')
